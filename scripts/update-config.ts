#!/usr/bin/env node
/**
 * Script de Mise √† Jour Configuration Supabase
 * ============================================
 * Met √† jour automatiquement la configuration Supabase dans l'application
 * pour pointer vers une nouvelle instance (cloud vers auto-h√©berg√© ou vice-versa)
 */

import fs from 'fs';
import path from 'path';

interface SupabaseConfig {
  url: string;
  key: string;
  description?: string;
}

interface UpdateOptions {
  target: SupabaseConfig;
  createBackup: boolean;
  backupDir: string;
  validateConfig: boolean;
}

class SupabaseConfigUpdater {
  private configFilePath: string;
  private options: UpdateOptions;
  private timestamp: string;

  constructor(options: UpdateOptions) {
    this.options = options;
    this.configFilePath = path.join(process.cwd(), 'src/integrations/supabase/client.ts');
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  }

  private log(message: string, level: 'info' | 'warn' | 'error' = 'info') {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
  }

  // V√©rification que le fichier de configuration existe
  private validateConfigFile(): boolean {
    if (!fs.existsSync(this.configFilePath)) {
      this.log(`Fichier de configuration non trouv√©: ${this.configFilePath}`, 'error');
      return false;
    }

    this.log(`Fichier de configuration trouv√©: ${this.configFilePath}`);
    return true;
  }

  // Lecture de la configuration actuelle
  private readCurrentConfig(): string | null {
    try {
      const content = fs.readFileSync(this.configFilePath, 'utf8');
      
      // Extraction des valeurs actuelles pour logging
      const urlMatch = content.match(/export const SUPABASE_URL = ["']([^"']+)["']/);
      const keyMatch = content.match(/export const SUPABASE_PUBLISHABLE_KEY = ["']([^"']+)["']/);
      
      if (urlMatch && keyMatch) {
        this.log(`Configuration actuelle - URL: ${urlMatch[1]}`);
        this.log(`Configuration actuelle - Cl√©: ${keyMatch[1].substring(0, 20)}...`);
      }
      
      return content;
    } catch (error) {
      this.log(`Erreur lecture configuration: ${error}`, 'error');
      return null;
    }
  }

  // Cr√©ation d'une sauvegarde
  private createBackup(content: string): boolean {
    if (!this.options.createBackup) {
      return true;
    }

    try {
      // Cr√©ation du r√©pertoire de backup
      const backupDir = path.join(this.options.backupDir, 'config-backups');
      const migrationBackupDir = path.join(backupDir, `pre-migration-${this.timestamp}`);
      
      if (!fs.existsSync(migrationBackupDir)) {
        fs.mkdirSync(migrationBackupDir, { recursive: true });
      }

      // Sauvegarde du fichier
      const backupPath = path.join(migrationBackupDir, 'client.ts.backup');
      fs.writeFileSync(backupPath, content);
      
      // Cr√©ation d'un fichier de m√©tadonn√©es
      const metadataPath = path.join(migrationBackupDir, 'backup_metadata.json');
      const metadata = {
        timestamp: new Date().toISOString(),
        originalPath: this.configFilePath,
        backupReason: 'Pre-migration backup',
        targetUrl: this.options.target.url,
        targetDescription: this.options.target.description || 'Configuration update'
      };
      fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));

      this.log(`‚úÖ Sauvegarde cr√©√©e: ${backupPath}`);
      return true;
    } catch (error) {
      this.log(`Erreur cr√©ation sauvegarde: ${error}`, 'error');
      return false;
    }
  }

  // G√©n√©ration du nouveau contenu de configuration
  private generateNewConfig(): string {
    const { url, key, description } = this.options.target;
    
    return `
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types.ts';

export const SUPABASE_URL = "${url}";
export const SUPABASE_PUBLISHABLE_KEY = "${key}";

// Configuration mise √† jour le ${new Date().toISOString()}
// ${description || 'Migration configuration update'}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Initialize Supabase client
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    debug: false, // Disable debug mode to reduce potential issues
  }
});

// Completely clear all auth data (for debugging) - not used in the app but can be used to clear the auth state if needed (e.g. if you want to test the auth flow)
export const cleanupAuthState = () => {
  try {
    // Clear all localStorage items related to Supabase auth
    Object.keys(localStorage).forEach(key => {
      if (key.includes('supabase') || key.includes('sb-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Clear all sessionStorage items related to Supabase auth
    Object.keys(sessionStorage || {}).forEach(key => {
      if (key.includes('supabase') || key.includes('sb-')) {
        sessionStorage.removeItem(key);
      }
    });
    
    // Clear any cookies related to auth (optional but thorough)
    document.cookie.split(';').forEach(cookie => {
      const [name] = cookie.split('=');
      if (name.trim().includes('sb-')) {
        document.cookie = \`\${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\`;
      }
    });
    
  } catch (error) {
    console.error('Error cleaning up auth state:', error);
  }
};
`;
  }

  // √âcriture de la nouvelle configuration
  private writeNewConfig(newContent: string): boolean {
    try {
      fs.writeFileSync(this.configFilePath, newContent);
      this.log(`‚úÖ Configuration mise √† jour: ${this.configFilePath}`);
      return true;
    } catch (error) {
      this.log(`Erreur √©criture configuration: ${error}`, 'error');
      return false;
    }
  }

  // Validation basique de la nouvelle configuration
  private validateNewConfig(): boolean {
    if (!this.options.validateConfig) {
      return true;
    }

    try {
      const content = fs.readFileSync(this.configFilePath, 'utf8');
      
      // V√©rifications basiques
      if (!content.includes('SUPABASE_URL')) {
        this.log('SUPABASE_URL manquant dans la nouvelle configuration', 'error');
        return false;
      }
      
      if (!content.includes('SUPABASE_PUBLISHABLE_KEY')) {
        this.log('SUPABASE_PUBLISHABLE_KEY manquant dans la nouvelle configuration', 'error');
        return false;
      }
      
      if (!content.includes(this.options.target.url)) {
        this.log('URL cible non trouv√©e dans la configuration', 'error');
        return false;
      }
      
      if (!content.includes(this.options.target.key)) {
        this.log('Cl√© cible non trouv√©e dans la configuration', 'error');
        return false;
      }
      
      this.log('‚úÖ Validation de la nouvelle configuration r√©ussie');
      return true;
    } catch (error) {
      this.log(`Erreur validation configuration: ${error}`, 'error');
      return false;
    }
  }

  // Mise √† jour d'autres fichiers si n√©cessaire
  private updateEnvironmentFiles(): boolean {
    try {
      // Mise √† jour du .env.example si il existe
      const envExamplePath = path.join(process.cwd(), '.env.example');
      if (fs.existsSync(envExamplePath)) {
        let envContent = fs.readFileSync(envExamplePath, 'utf8');
        
        // Mise √† jour des variables d'exemple
        envContent = envContent.replace(
          /VITE_SUPABASE_URL=.*/,
          `VITE_SUPABASE_URL=${this.options.target.url}`
        );
        
        // Note: on ne met pas la vraie cl√© dans .env.example
        envContent = envContent.replace(
          /VITE_SUPABASE_PUBLISHABLE_KEY=.*/,
          'VITE_SUPABASE_PUBLISHABLE_KEY=your_supabase_anon_key'
        );
        
        fs.writeFileSync(envExamplePath, envContent);
        this.log(`‚úÖ .env.example mis √† jour`);
      }
      
      return true;
    } catch (error) {
      this.log(`Erreur mise √† jour fichiers environnement: ${error}`, 'warn');
      return true; // Non bloquant
    }
  }

  // G√©n√©ration d'un rapport de mise √† jour
  private generateUpdateReport(): void {
    const reportPath = path.join(this.options.backupDir, `config_update_${this.timestamp}.json`);
    
    const report = {
      timestamp: new Date().toISOString(),
      action: 'configuration_update',
      target: this.options.target,
      configFile: this.configFilePath,
      backupCreated: this.options.createBackup,
      validationPerformed: this.options.validateConfig,
      status: 'success'
    };
    
    try {
      if (!fs.existsSync(this.options.backupDir)) {
        fs.mkdirSync(this.options.backupDir, { recursive: true });
      }
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      this.log(`üìÑ Rapport de mise √† jour: ${reportPath}`);
    } catch (error) {
      this.log(`Erreur g√©n√©ration rapport: ${error}`, 'warn');
    }
  }

  // Ex√©cution de la mise √† jour compl√®te
  async updateConfig(): Promise<boolean> {
    this.log('üöÄ D√©marrage de la mise √† jour de configuration Supabase');
    this.log(`Nouvelle URL: ${this.options.target.url}`);
    this.log(`Description: ${this.options.target.description || 'Configuration update'}`);

    try {
      // √âtape 1: Validation du fichier
      if (!this.validateConfigFile()) {
        return false;
      }

      // √âtape 2: Lecture de la configuration actuelle
      const currentContent = this.readCurrentConfig();
      if (!currentContent) {
        return false;
      }

      // √âtape 3: Cr√©ation de la sauvegarde
      if (!this.createBackup(currentContent)) {
        return false;
      }

      // √âtape 4: G√©n√©ration et √©criture de la nouvelle configuration
      const newContent = this.generateNewConfig();
      if (!this.writeNewConfig(newContent)) {
        return false;
      }

      // √âtape 5: Validation de la nouvelle configuration
      if (!this.validateNewConfig()) {
        return false;
      }

      // √âtape 6: Mise √† jour des autres fichiers
      this.updateEnvironmentFiles();

      // √âtape 7: G√©n√©ration du rapport
      this.generateUpdateReport();

      this.log('üéâ Mise √† jour de configuration termin√©e avec succ√®s!');
      this.log('‚ö†Ô∏è N\'oubliez pas de rebuilder l\'application');
      
      return true;
    } catch (error) {
      this.log(`Erreur g√©n√©rale: ${error}`, 'error');
      return false;
    }
  }
}

// Fonction principale
async function main() {
  const args = process.argv.slice(2);
  
  // Affichage de l'aide
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Mise √† jour Configuration Supabase

Usage: node update-config.ts [options]

Variables d'environnement:
  SUPABASE_TARGET_URL           URL de l'instance Supabase cible (requis)
  SUPABASE_TARGET_KEY           Cl√© API de l'instance cible (requis)
  SUPABASE_TARGET_DESCRIPTION   Description de la mise √† jour (optionnel)
  BACKUP_DIR                    R√©pertoire des sauvegardes (d√©faut: ./migration-backups)
  SKIP_BACKUP                   Skip la cr√©ation de sauvegarde (d√©faut: false)
  SKIP_VALIDATION               Skip la validation (d√©faut: false)

Exemples:
  # Migration vers auto-h√©berg√© (utilise les variables .env)
  export SUPABASE_TARGET_URL="https://services-supabase.clubcreole.fr"
  export SUPABASE_TARGET_KEY="$SERVICE_SUPABASE_ANON_KEY"
  export SUPABASE_TARGET_DESCRIPTION="Migration vers instance auto-h√©berg√©e ClubCreole"
  node update-config.ts

  # Ou utilisation automatique des variables .env (recommand√©)
  # Les variables SERVICE_SUPABASE_ANON_KEY sont automatiquement d√©tect√©es
  node update-config.ts

  # Rollback vers cloud
  export SUPABASE_TARGET_URL="https://psryoyugyimibjhwhvlh.supabase.co"
  export SUPABASE_TARGET_KEY="$VITE_SUPABASE_PUBLISHABLE_KEY"
  export SUPABASE_TARGET_DESCRIPTION="Rollback vers Supabase cloud"
  node update-config.ts
`);
    process.exit(0);
  }

  // Lecture des variables d'environnement avec auto-d√©tection
  let targetUrl = process.env.SUPABASE_TARGET_URL;
  let targetKey = process.env.SUPABASE_TARGET_KEY;
  
  // Auto-d√©tection de la configuration cible depuis .env
  if (!targetUrl && process.env.SERVICE_SUPABASE_ANON_KEY) {
    targetUrl = 'https://services-supabase.clubcreole.fr';
    console.log('üîç URL cible auto-d√©tect√©e: https://services-supabase.clubcreole.fr');
  }
  
  if (!targetKey && process.env.SERVICE_SUPABASE_ANON_KEY) {
    targetKey = process.env.SERVICE_SUPABASE_ANON_KEY;
    console.log('üîç Cl√© cible auto-d√©tect√©e depuis SERVICE_SUPABASE_ANON_KEY');
  }

  const targetDescription = process.env.SUPABASE_TARGET_DESCRIPTION || 
                           'Migration vers instance Supabase auto-h√©berg√©e';
  const backupDir = process.env.BACKUP_DIR || './migration-backups';
  const skipBackup = process.env.SKIP_BACKUP === 'true';
  const skipValidation = process.env.SKIP_VALIDATION === 'true';

  // Validation des param√®tres requis
  if (!targetUrl || !targetKey) {
    console.error('‚ùå Configuration cible requise');
    console.error('');
    console.error('Options:');
    console.error('  1. Variables explicites:');
    console.error('     export SUPABASE_TARGET_URL="https://your-instance.com"');
    console.error('     export SUPABASE_TARGET_KEY="your_api_key"');
    console.error('');
    console.error('  2. Auto-d√©tection depuis .env:');
    console.error('     SERVICE_SUPABASE_ANON_KEY (d√©tect√©: ' + 
                  (process.env.SERVICE_SUPABASE_ANON_KEY ? 'Oui' : 'Non') + ')');
    console.error('');
    console.error('√âtat actuel:');
    console.error('  Target URL: ' + (targetUrl || 'Non d√©finie'));
    console.error('  Target Key: ' + (targetKey ? 'Pr√©sente' : 'Manquante'));
    process.exit(1);
  }

  // Configuration de la mise √† jour
  const options: UpdateOptions = {
    target: {
      url: targetUrl,
      key: targetKey,
      description: targetDescription
    },
    createBackup: !skipBackup,
    backupDir,
    validateConfig: !skipValidation
  };

  // Ex√©cution de la mise √† jour
  const updater = new SupabaseConfigUpdater(options);
  const success = await updater.updateConfig();
  
  process.exit(success ? 0 : 1);
}

// Gestion des erreurs non captur√©es
process.on('unhandledRejection', (reason, promise) => {
  console.error('Erreur non g√©r√©e:', reason);
  process.exit(1);
});

// Ex√©cution si script appel√© directement
if (require.main === module) {
  main().catch(console.error);
}

export { SupabaseConfigUpdater, UpdateOptions, SupabaseConfig };